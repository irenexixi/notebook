
[来源]：https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array

1. array.concat(item…)

concat方法产生一个新的数组。它包含一份array的浅复制并把一个或多个参数item附加在其后。如果参数item是一个数组，
那么它的每个元素会被分别添加。

var a = ['a', 'b', 'c'];
var b = ['x', 'y', 'z'];
var c = a.concat(b, true);   //['a', 'b', 'c', 'x', 'y', 'z',true]


2. array.join(separator)

join方法把一个array 构造成一个字符串。它先把array中的每个元素构造成一个字符串，接着用一个 separator分隔符 把他们连接在一起。
默认的separator是逗号’,’。

如果想要把大量的字符串片段组装成一个字符串，把这些片段放到一个数组中并用join方法连接起来通常比+元素运算符连接这些片段要快
（IE6/7是这样，ie8+，chrome等不是这样）。

var a = ['a', 'b', 'c'];
a.push('d');
var c = a.join('');  //abcd


3. array.pop()

pop和push方法使得数组array可以像堆栈一样工作。pop方法 移除array中的最后一个元素并返回该元素, 会修改array。
如果该array是empty，它会返回 undefined。

var a = ['a', 'b', 'c'];
var c = a.pop();  //a是['a', 'b'], c是'c'


4. array.push(item…)

push方法把一个或多个参数item 追加到一个数组的尾部。和concat方法不同的是，它会 修改array，如果item是一个数组，
它会把这个数组作为单个元素添加到数组中，并 返回这个array的新长度。

var a = ['a', 'b', 'c'];
var b = ['x', 'y', 'z'];
var c = a.push(b, true);
a;  //["a", "b", "c", Array[3], true]
c;  //5 


5. array.reverse()
reverse方法 反转array里的元素的顺序，并返回array本身。

var a = ['a', 'b', 'c'];
var b = a.reverse(); 
//a, ['c', 'b', 'a'];
//b, ['c', 'b', 'a'];


6. array.shift()
shift方法 移除数组array中的第一个元素并返回该元素。如果这个数组array是空的，它会返回undefined. shift通常比pop慢很多。

var a = ['a', 'b', 'c'];
var c = a.shift(); 
//a 是 ['a', 'b', 'c']; 
//c 是 'a'

可以这样实现：

Array.method('shift', function(){
    return this.splice(0, 1)[0];
});


7. array.slice(start, end)

slice方法 对数组array中的一段做浅复制。复制array[start]到array[end],end参数可选，默认值是该数组的长度。 
如果start大于等于array的长度，返回空。

var a = ['a', 'b', 'c'];
var b = a.slice(0,1); 
var c = a.slice(1); 
var d = a.slice(1,2); 
var e = a.slice(-1,-2); 
//b 是 ["a"]; 
//c 是 ["b", "c"]; 
//d 是 ["b"]
//e 是 []

数组的slice方法可以将类似数组的对象，变成真正的数组 
var arr = Array.prototype.slice.call(arrayLike);

8. array.sort(comparefn)

sort方法对array中的内容进行排序。它不能正确的给一组数字排序。

var n = ['4', '8', '15', '16', '23', '42'];
n.sort(); //n是 ["15", "16", "23", "4", "42", "8"]

JavaScript的默认 比较函数把要排序的元素视为字符串。并未在比较这些元素之前先检测他们的类型，所以比较数字时，会将它们转换成字符串，
于是得到一个错误的结果。

幸运的是，可以使用自己的比较函数来替换默认的比较函数。比较函数接收两个参数，如果这两个参数相等则返回0，如果第一个参数应该排在前面，返回一个负数，
如果第二个参数排在前面，则返回一个正数。

n.sort(function(a, b){
    return a-b
});   //["4", "8", "15", "16", "23", "42"]

var m = ['aa', 'bb', 'a', 4, 8, 15, 16, 23, 42];
m.sort(function(a, b){
    if(a === b){
        return 0;
    }

   if(typeof a === typeof b){
       return a < b ? -1 : 1;
   }

   return typeof a < typeof b ? -1:1;

});  
console.log(m); //[4, 8, 15, 16, 23, 42, "a", "aa", "bb"]

//m = ['aa', 'bb', 'aa', '4', '8', '15', '16', '23', '42'];
//输出：["15", "16", "23", "4", "42", "8", "aa", "aa", "bb"]

//m = ['aa', 'bb', 'A', '4', '8', '15', '16', '23', '42'];
//输出：["15", "16", "23", "4", "42", "8", "A", "aa", "bb"]

//m = ['aa', 'bb', 'AA', '4', '8', '15', '16', '23', '42'];
//输出：["15", "16", "23", "4", "42", "8", "AA", "aa", "bb"]

如果大小写不重要，比较函数应该在比较之前先将两个运算符转换为小写。

更智能的比较函数。

//by函数接受一个成员名字符串作为参数
//并返回一个可以用来对包含该成员的对象数组进行排序的比较函数。
var by = function (name) {
    return function (o, p) {
        var a, b;
        if (typeof o === 'object' && typeof p === 'object' && o && p) {
            a = o[name];
            b = p[name];
            if (a === b) {
                return 0;
            }
            if (typeof a === typeof b) {
                return a < b ? -1 : 1;
            }
            return typeof a < typeof b ? -1 : 1;
        } else {
            throw {
                name: 'Error',
                message: 'Expected an object when sorting by ' + name
            }
        }
    }
};
var s = [
    {first: 'Joe', last: 'Besser'},
    {first: 'Moe', last: 'Hesser'},
    {first: 'Joe', last: 'Desser'},
    {first: 'Soe', last: 'Hesser'},
    {first: 'Loe', last: 'Fesser'},
    {first: 'Coe', last: 'Hesser'}
];
console.log(s.sort(by('first')));
//console.log(s.sort(by('first')).sort(by('last'))); 不能保证顺序是对的

如果想要基于多个键值进行排序，修改by函数，让其可以接受第二个参数，当主要的键值产生一个匹配的时候，另一个compare方法将被调用已决高下。

var by = function (name, minor) {
    return function (o, p) {
        var a, b;
        if (o && p && typeof o === 'object' && typeof p === 'object') {
            a = o[name];
            b = p[name];
            if (a === b) {
                return typeof minor === 'function' ? minor(o, p) : 0;
            }
            if (typeof a === typeof b) {
                return a < b ? -1 : 1;
            }
            return typeof a < typeof b ? -1 : 1;
        } else {
            throw {
                name: 'Error',
                message: 'Expected an object when sorting by ' + name
            }
        }
    }
};
s.sort(by('last', by('first')));


9. array.splice(start, deleteCount,item…)

splice方法从array中 移除一个或多个元素，并用新的item替换他们。start是从数组array中移除元素的开始位置，deleteCount是要移除的元素个数，item会插入到被移除元素的位置上。返回一个包含被移除元素的数组。

splice主要的用处是从一个数组中删除元素。

var a = ['a','b','c'];
var r = a.splice(1,1,'ache','bug');
//a, ["a", "ache", "bug", "c"]
//r, ["b"]



10. array.unshift(item…)

unshift方法像push方法一样，用于把元素添加到数组中，但它是 把item插入到array的开始部分 而不是尾部。它返回array的新的length。

var a = ['a','b','c'];
var r = a.unshift('?','@');
//a, ["?", "@", "a", "b", "c"]
//r, 5

推荐些的较好的博客：http://www.cnblogs.com/tianguook/archive/2010/09/30/1839648.html


11、判断一个变量是数组

// 这里提供两种js方法。返回true则是数组。

var array = new Array("1", "2", "3", "4", "5");
alert(array instanceof Array);
alert(array.constructor == Array);

// 较为严谨并且通用的方法：
function isArray(object){
    return object && typeof object==='object' &&
            Array == object.constructor;
}

详细说明链接 http://www.cnblogs.com/mofish/p/3388427.html


12、Array.prototype.forEach.call

由于字符串也是类似数组的对象，所以也可以用遍历。

Array.prototype.forEach.call('abc', function(chr) {
  console.log(chr);
});
// a
// b
// c


